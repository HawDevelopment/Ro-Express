{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ro-Express Ro-Express is a Networking module based on express-js . It makes creating Remotes easier, while implementing lots of useful features. Its best used for Big and Complex games, when it can be hard keeping track of things. It really shines with Git and Rojo. Start here: Getting Started","title":"Home"},{"location":"#ro-express","text":"Ro-Express is a Networking module based on express-js . It makes creating Remotes easier, while implementing lots of useful features. Its best used for Big and Complex games, when it can be hard keeping track of things. It really shines with Git and Rojo. Start here: Getting Started","title":"Ro-Express"},{"location":"Api/","text":"Express Houses all the components of Ro-Express. Contains: App Request Response App The app is the way you register Methods and create Middleware, it also builds the finale tree of Remotes. An app can be made on the server and client. An app can be made like this: local express = require ( path . to . express ) local app1 = express . App () -- Or local app2 = express . App . new () Get, Post, Delete, Put App:METHOD(path: string, callback: (Request, Response)): void Registers a callback with a type to the specified path. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : post ( \"/Method 2\" , function ( req , res ) end ) app : delete ( \"/Method 3\" , function ( req , res ) end ) app : put ( \"/Method 4\" , function ( req , res ) end ) App:all App:all(path: string, callback: (Request, Response)) Register an All method to the specified path, this means that the callback will be called on ANY reques to the path. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) print ( \"Get\" ) end ) app : all ( \"/Method 1\" , function ( req , res ) print ( \"All\" ) end ) -- When a GET Method 1 is called it will print All and then Get. App:Listen App:Listen(name: string | number): Instance Builds and Connects the current tree under ReplicatedStorage. Returns the top Instance of the Remote tree. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : Listen ( \"Tree\" ) App:use App:use(path: string, inst: Router | (Request, Response) -> ()): void Uses the given Middleware, and connects underlying instances to it. When the Method is called, any Middleware attached to it will be called first. For more information look here . local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : use ( \"/Method 1\" , function ( req , res ) end ) App:Destroy App:Destroy(): void Destroys the app, and the remote tree if built. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : Listen ( \"Tree\" ) app : Destroy () Request Request.new() Request.new(path: string, method: string, ...any) Make a request to a specific path with a method attached. Request.new can be called like Request() -- SERVER local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) res : send ( \"Hello World!\" ) end ) app : Listen ( \"Tree\" ) -- CLIENT local express = require ( path . to . express ) print ( express . Request ( \"Tree://Method 1\" , \"GET\" )) -> { Status = 200 , Succes = true , Body = \"Hello World!\" } Request.Player Request.Player: Player The caller of the Request. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) print ( req . Player . Name ) -- Prints the caller's name end ) Request.Body Request.Body: any All the args given from the caller. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) print ( req . Body ) -- Prints all the arguments given end ) Request.Method Request.Method: string The request Method, eg. GET, POST, DELETE, and PUT. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) pring ( req . Method ) -> \"GET\" end ) Request.Path Request.Path: string local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) pring ( req . Path ) -> \"/Method 1\" end ) Request:param Request:param(index: string | number, default: any?): any Returns the first arguments in the Body with given index, if none is found it returns the default param. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- Prints the value of that index in the args pring ( req : param ( \"Foo Bar Bazz\" )) end ) Response Response.Succes Response.Succes: boolean Is true if no error happened while Requesting. local express = require ( path . to . express ) print ( express . Request ( \"Tree://Method 1\" , \"GET\" ). Succes ) -> true Response.Status Response.Status: number The returned status from the Request. local express = require ( path . to . express ) print ( express . Request ( \"Tree://Method 1\" , \"GET\" ). Status ) -> 200 Response.Locals Response.Locals: {[any]: any} Serves as a way to share variables between Middleware. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) pring ( res . Locals [ 1 ]) -> \"Hello World\" end ) app : use ( \"/Method 1\" , function ( req , res ) res . Locals [ 1 ] = \"Hello World\" end ) Warning Locals can be changed by any Middlware Response:send Response:send(...any): Response Sets the Response value to the given arguments. Can be chained. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- The caller will get \"Hello World\" back res : send ( \"Hello World\" ) end ) Warning Response:send can be called from any Middleware Response:status Response:status(status: number): Response Sets the status of the Response to the given number. Can be chained. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- The caller will get the status 200 back res : status ( 200 ) end ) Warning Response:status can be called from any Middleware Response:done Response:done(): Response Locks the Response so any changes will not happen. Can be chained. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- The caller will get the status 200 back res : status ( 200 ): send ( \"Hello World\" ) res : done () -- It will still return \"Hello World\" with status 200 res : send ( \"Foo Bar Baz\" ) end ) Warning Response:done can be called from any Middleware","title":"Api"},{"location":"Api/#express","text":"Houses all the components of Ro-Express. Contains: App Request Response","title":"Express"},{"location":"Api/#app","text":"The app is the way you register Methods and create Middleware, it also builds the finale tree of Remotes. An app can be made on the server and client. An app can be made like this: local express = require ( path . to . express ) local app1 = express . App () -- Or local app2 = express . App . new ()","title":"App"},{"location":"Api/#get-post-delete-put","text":"App:METHOD(path: string, callback: (Request, Response)): void Registers a callback with a type to the specified path. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : post ( \"/Method 2\" , function ( req , res ) end ) app : delete ( \"/Method 3\" , function ( req , res ) end ) app : put ( \"/Method 4\" , function ( req , res ) end )","title":"Get, Post, Delete, Put"},{"location":"Api/#appall","text":"App:all(path: string, callback: (Request, Response)) Register an All method to the specified path, this means that the callback will be called on ANY reques to the path. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) print ( \"Get\" ) end ) app : all ( \"/Method 1\" , function ( req , res ) print ( \"All\" ) end ) -- When a GET Method 1 is called it will print All and then Get.","title":"App:all"},{"location":"Api/#applisten","text":"App:Listen(name: string | number): Instance Builds and Connects the current tree under ReplicatedStorage. Returns the top Instance of the Remote tree. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : Listen ( \"Tree\" )","title":"App:Listen"},{"location":"Api/#appuse","text":"App:use(path: string, inst: Router | (Request, Response) -> ()): void Uses the given Middleware, and connects underlying instances to it. When the Method is called, any Middleware attached to it will be called first. For more information look here . local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : use ( \"/Method 1\" , function ( req , res ) end )","title":"App:use"},{"location":"Api/#appdestroy","text":"App:Destroy(): void Destroys the app, and the remote tree if built. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) end ) app : Listen ( \"Tree\" ) app : Destroy ()","title":"App:Destroy"},{"location":"Api/#request","text":"","title":"Request"},{"location":"Api/#requestnew","text":"Request.new(path: string, method: string, ...any) Make a request to a specific path with a method attached. Request.new can be called like Request() -- SERVER local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) res : send ( \"Hello World!\" ) end ) app : Listen ( \"Tree\" ) -- CLIENT local express = require ( path . to . express ) print ( express . Request ( \"Tree://Method 1\" , \"GET\" )) -> { Status = 200 , Succes = true , Body = \"Hello World!\" }","title":"Request.new()"},{"location":"Api/#requestplayer","text":"Request.Player: Player The caller of the Request. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) print ( req . Player . Name ) -- Prints the caller's name end )","title":"Request.Player"},{"location":"Api/#requestbody","text":"Request.Body: any All the args given from the caller. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) print ( req . Body ) -- Prints all the arguments given end )","title":"Request.Body"},{"location":"Api/#requestmethod","text":"Request.Method: string The request Method, eg. GET, POST, DELETE, and PUT. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) pring ( req . Method ) -> \"GET\" end )","title":"Request.Method"},{"location":"Api/#requestpath","text":"Request.Path: string local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) pring ( req . Path ) -> \"/Method 1\" end )","title":"Request.Path"},{"location":"Api/#requestparam","text":"Request:param(index: string | number, default: any?): any Returns the first arguments in the Body with given index, if none is found it returns the default param. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- Prints the value of that index in the args pring ( req : param ( \"Foo Bar Bazz\" )) end )","title":"Request:param"},{"location":"Api/#response","text":"","title":"Response"},{"location":"Api/#responsesucces","text":"Response.Succes: boolean Is true if no error happened while Requesting. local express = require ( path . to . express ) print ( express . Request ( \"Tree://Method 1\" , \"GET\" ). Succes ) -> true","title":"Response.Succes"},{"location":"Api/#responsestatus","text":"Response.Status: number The returned status from the Request. local express = require ( path . to . express ) print ( express . Request ( \"Tree://Method 1\" , \"GET\" ). Status ) -> 200","title":"Response.Status"},{"location":"Api/#responselocals","text":"Response.Locals: {[any]: any} Serves as a way to share variables between Middleware. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) pring ( res . Locals [ 1 ]) -> \"Hello World\" end ) app : use ( \"/Method 1\" , function ( req , res ) res . Locals [ 1 ] = \"Hello World\" end ) Warning Locals can be changed by any Middlware","title":"Response.Locals"},{"location":"Api/#responsesend","text":"Response:send(...any): Response Sets the Response value to the given arguments. Can be chained. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- The caller will get \"Hello World\" back res : send ( \"Hello World\" ) end ) Warning Response:send can be called from any Middleware","title":"Response:send"},{"location":"Api/#responsestatus_1","text":"Response:status(status: number): Response Sets the status of the Response to the given number. Can be chained. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- The caller will get the status 200 back res : status ( 200 ) end ) Warning Response:status can be called from any Middleware","title":"Response:status"},{"location":"Api/#responsedone","text":"Response:done(): Response Locks the Response so any changes will not happen. Can be chained. local express = require ( path . to . express ) local app = express . App () app : get ( \"/Method 1\" , function ( req , res ) -- The caller will get the status 200 back res : status ( 200 ): send ( \"Hello World\" ) res : done () -- It will still return \"Hello World\" with status 200 res : send ( \"Foo Bar Baz\" ) end ) Warning Response:done can be called from any Middleware","title":"Response:done"},{"location":"Example/","text":"Example Code Server - Client Since Ro-Express is all about networking this shouldnt come as a suprise. But it can be hard to grasp for newcomers when starting out with the Module. Heres some code that makes two methods, one to update money and a second to get money. Server local express = require ( path . to . express ) local app : App = express . App . new () local Money = {} app : get ( \"/GetMoney\" , function ( req : Request , res : Response ) -- Response Status will defualt to 200, so we dont have to call it. res : send ( Money [ req . Player ] or 0 ) end ) app : post ( \"/SetMoney\" , function ( req : Request , res : Response ) assert ( req . Body , \"Need a valid amount of Money to set!\" ) Money [ req . Player ] = req . Body res : send ( \"We set the Money!\" ) end ) app : Listen ( \"MoneyTree\" ) Client local express = require ( path . to . express ) local Return = express . Request . new ( \"MoneyTree://GetMoney\" , \"Get\" ). Body express . Request . new ( \"MoneyTree://SetMoney\" , \"Post\" , Return + 10 ) print ( express . Request . new ( \"MoneyTree://GetMoney\" , \"Get\" ). Body ) -- Prints 10 With this you can Get and Change your money from the methods. Auth The best use for Middleware is guarding for bad requests. Lets say you have an Admin system, you can use middleware for guarding all Methods. Server local express = require ( path . to . express ) local app : App = express . App . new () local VerifiedUsers = { \"HawDevelopment\" , \"Elttob\" , \"ScriptOn\" , \"Sleitnick\" , } app : get ( \"/GetHugs\" , function ( _ : Request , res : Response ) res : send ( \"Hugs \ud83e\udd17\" ) end ) app : use ( \"/\" , function ( req , res ) local isVerified = false for _ , name in pairs ( VerifiedUsers ) do if req . Player . Name == name then isVerified = true break end end if not isVerified then res : status ( 401 ): send ( \"Your not Authorized to do that!\" ): done () end end ) app : Listen ( \"AuthTree\" ) Client local express = require ( ReplicatedStorage . express ) local Return = express . Request . new ( \"AuthTree://GetHugs\" , \"Get\" ) if Return . Status == 401 or not Return . Succes then print ( \"You are not Authorized!\" ) else print ( \"Get some hugs: \" .. Return . Body ) -- Prints \"Get some hugs: Hugs \ud83e\udd17\" end When Requesting something from \u00b4/GetHugs\u00b4 you will get hugs if you are authorized!","title":"Examples"},{"location":"Example/#example-code","text":"","title":"Example Code"},{"location":"Example/#server-client","text":"Since Ro-Express is all about networking this shouldnt come as a suprise. But it can be hard to grasp for newcomers when starting out with the Module. Heres some code that makes two methods, one to update money and a second to get money. Server local express = require ( path . to . express ) local app : App = express . App . new () local Money = {} app : get ( \"/GetMoney\" , function ( req : Request , res : Response ) -- Response Status will defualt to 200, so we dont have to call it. res : send ( Money [ req . Player ] or 0 ) end ) app : post ( \"/SetMoney\" , function ( req : Request , res : Response ) assert ( req . Body , \"Need a valid amount of Money to set!\" ) Money [ req . Player ] = req . Body res : send ( \"We set the Money!\" ) end ) app : Listen ( \"MoneyTree\" ) Client local express = require ( path . to . express ) local Return = express . Request . new ( \"MoneyTree://GetMoney\" , \"Get\" ). Body express . Request . new ( \"MoneyTree://SetMoney\" , \"Post\" , Return + 10 ) print ( express . Request . new ( \"MoneyTree://GetMoney\" , \"Get\" ). Body ) -- Prints 10 With this you can Get and Change your money from the methods.","title":"Server - Client"},{"location":"Example/#auth","text":"The best use for Middleware is guarding for bad requests. Lets say you have an Admin system, you can use middleware for guarding all Methods. Server local express = require ( path . to . express ) local app : App = express . App . new () local VerifiedUsers = { \"HawDevelopment\" , \"Elttob\" , \"ScriptOn\" , \"Sleitnick\" , } app : get ( \"/GetHugs\" , function ( _ : Request , res : Response ) res : send ( \"Hugs \ud83e\udd17\" ) end ) app : use ( \"/\" , function ( req , res ) local isVerified = false for _ , name in pairs ( VerifiedUsers ) do if req . Player . Name == name then isVerified = true break end end if not isVerified then res : status ( 401 ): send ( \"Your not Authorized to do that!\" ): done () end end ) app : Listen ( \"AuthTree\" ) Client local express = require ( ReplicatedStorage . express ) local Return = express . Request . new ( \"AuthTree://GetHugs\" , \"Get\" ) if Return . Status == 401 or not Return . Succes then print ( \"You are not Authorized!\" ) else print ( \"Get some hugs: \" .. Return . Body ) -- Prints \"Get some hugs: Hugs \ud83e\udd17\" end When Requesting something from \u00b4/GetHugs\u00b4 you will get hugs if you are authorized!","title":"Auth"},{"location":"Getting_Started/","text":"Basics Ro-Express syntax is based on express-js . In Ro-Express all Instances in a tree, has at least one Http method attached to it. This makes it easy to categorise Remotes, or have many callbacks attached to one path. Heres what a normal Ro-Express tree: Tree Method 1 (GET) Method 2 (DELETE) Method 3 (POST) We can make something like that with this code: local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () app : get ( \"/Method 1\" , function () end ) app : delete ( \"/Method 2\" , function () end ) app : post ( \"/Method 2\" , function () end ) app : Listen ( \"Tree\" ) Apps or \"Trees\" can be made on both server and client. Request and Response You can use Request to get all the incoming data from the caller, and use Response to specify the response data. local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () app : get ( \"/Method 1\" , function ( req , res ) local args = req . Body -- the incoming data (a table) local method = req . Method -- the call type (GET, POST, DELETE etc.) local path = req . Path -- the call path (/Method 1) -- you can use :Param to get things from the body local Player = req : param ( \"Player\" ) or args [ 1 ] -- using response we can send data back. -- You should always send a status! res : status ( 200 ): send ( Player . Name or \"\" ) end ) app : Listen ( \"Tree\" ) Now when the client makes a GET request to Method 1 it we get its name! Making a Request Using the Request class you can make request to paths and trees. When making a Request you will need: The URL, with tree name and path. So something like Tree://Method 1 . The method. (GET, POST, DELETE, ) Arguments. -- Server local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () app : get ( \"/Method 1\" , function ( req , res ) res : status ( 200 ): send ( \"Hello World!\" ) end ) app : Listen ( \"Tree\" ) -- Client local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local Return = express . Request ( \"Tree://Method 1\" , \"GET\" ) print ( Return . Body ) -> \"Hello World!\" print ( Return . Succes ) -> true print ( Return . Status ) -> 200 Middleware Middleware is a function, that get called before the method attached to the path does. A Middleware function can also change or skip the current request. local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () -- create our method app : get ( \"/Method 1\" , function ( req , res ) local Player = req : param ( \"Player\" ) or args [ 1 ] res : status ( 200 ): send ( Player . Name or \"\" ) end ) -- This middleware will first be called and then the function for the method app : use ( \"/Method 1\" , function ( req , res ) res : send ( \"Hello World!\" ) -- this locks the current response or \"skips\" it as its called. res : done () end ) app : Listen ( \"Tree\" ) When we call any Method it will always return \"Hello World!\". Execution Model When requesting Ro-Express Execution Model looks like this: Call any parent middleware. Call path middleware. Call the ALL method for that path. (If exists) Call the path's method functions.","title":"Getting Started"},{"location":"Getting_Started/#basics","text":"Ro-Express syntax is based on express-js . In Ro-Express all Instances in a tree, has at least one Http method attached to it. This makes it easy to categorise Remotes, or have many callbacks attached to one path. Heres what a normal Ro-Express tree: Tree Method 1 (GET) Method 2 (DELETE) Method 3 (POST) We can make something like that with this code: local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () app : get ( \"/Method 1\" , function () end ) app : delete ( \"/Method 2\" , function () end ) app : post ( \"/Method 2\" , function () end ) app : Listen ( \"Tree\" ) Apps or \"Trees\" can be made on both server and client.","title":"Basics"},{"location":"Getting_Started/#request-and-response","text":"You can use Request to get all the incoming data from the caller, and use Response to specify the response data. local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () app : get ( \"/Method 1\" , function ( req , res ) local args = req . Body -- the incoming data (a table) local method = req . Method -- the call type (GET, POST, DELETE etc.) local path = req . Path -- the call path (/Method 1) -- you can use :Param to get things from the body local Player = req : param ( \"Player\" ) or args [ 1 ] -- using response we can send data back. -- You should always send a status! res : status ( 200 ): send ( Player . Name or \"\" ) end ) app : Listen ( \"Tree\" ) Now when the client makes a GET request to Method 1 it we get its name!","title":"Request and Response"},{"location":"Getting_Started/#making-a-request","text":"Using the Request class you can make request to paths and trees. When making a Request you will need: The URL, with tree name and path. So something like Tree://Method 1 . The method. (GET, POST, DELETE, ) Arguments. -- Server local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () app : get ( \"/Method 1\" , function ( req , res ) res : status ( 200 ): send ( \"Hello World!\" ) end ) app : Listen ( \"Tree\" ) -- Client local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local Return = express . Request ( \"Tree://Method 1\" , \"GET\" ) print ( Return . Body ) -> \"Hello World!\" print ( Return . Succes ) -> true print ( Return . Status ) -> 200","title":"Making a Request"},{"location":"Getting_Started/#middleware","text":"Middleware is a function, that get called before the method attached to the path does. A Middleware function can also change or skip the current request. local express = require ( game : GetService ( \"ReplicatedStorage\" ). express ) local app = express . App . new () -- create our method app : get ( \"/Method 1\" , function ( req , res ) local Player = req : param ( \"Player\" ) or args [ 1 ] res : status ( 200 ): send ( Player . Name or \"\" ) end ) -- This middleware will first be called and then the function for the method app : use ( \"/Method 1\" , function ( req , res ) res : send ( \"Hello World!\" ) -- this locks the current response or \"skips\" it as its called. res : done () end ) app : Listen ( \"Tree\" ) When we call any Method it will always return \"Hello World!\".","title":"Middleware"},{"location":"Getting_Started/#execution-model","text":"When requesting Ro-Express Execution Model looks like this: Call any parent middleware. Call path middleware. Call the ALL method for that path. (If exists) Call the path's method functions.","title":"Execution Model"},{"location":"Installation/","text":"Installation I recommend using Rojo, as its where the power of Ro-Express really shines. Its also best used with git. Also, you should update the module to new versions regularly. Roblox Studio: Get the Module from the Library . Place the Module within ReplicatedStorage. Rojo workflow: Download the Ro-Express from the latest release . Extract the Module from the zipped file. Place the Module in ReplicatedStorage. Git workflow: Run git submodule add https://github.com/HawDevelopment/Ro-Express Point the Submodule folder to ReplicatedStorage using Rojo.","title":"Installation"},{"location":"Installation/#installation","text":"I recommend using Rojo, as its where the power of Ro-Express really shines. Its also best used with git. Also, you should update the module to new versions regularly. Roblox Studio: Get the Module from the Library . Place the Module within ReplicatedStorage. Rojo workflow: Download the Ro-Express from the latest release . Extract the Module from the zipped file. Place the Module in ReplicatedStorage. Git workflow: Run git submodule add https://github.com/HawDevelopment/Ro-Express Point the Submodule folder to ReplicatedStorage using Rojo.","title":"Installation"}]}